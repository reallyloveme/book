{"./":{"url":"./","title":"概况","keywords":"","body":" songjun的个人知识整理 个人笔记整理和收集 powered by Gitbook该文件最后修改时间： 2021-10-16 14:33:35 "},"css知识点/双飞翼和圣杯布局.html":{"url":"css知识点/双飞翼和圣杯布局.html","title":"css基础知识","keywords":"","body":"双飞翼和圣杯布局 powered by Gitbook该文件最后修改时间： 2021-10-16 18:55:33 "},"js知识点/数据结构类型.html":{"url":"js知识点/数据结构类型.html","title":"javascript知识","keywords":"","body":"数据结构类型 powered by Gitbook该文件最后修改时间： 2021-10-16 19:03:06 "},"js知识点/Promise.html":{"url":"js知识点/Promise.html","title":"Promise","keywords":"","body":"Promise promise方法 promise对象 注意点： 参数resolver必须是Function Promise实例（this）贯穿全文 普通new Promise()执行过程 // ! 创建promise对象 function Promise(resolver) { // !创建promise id // ? 每执行一次promise就会创建一个promise id this[PROMISE_ID] = nextId(); // !设置 初始状态和结果 this._result = this._state = undefined; // ! 初始化_subscribers属性，说明Promise使用发布订阅模式，间接证明Promise是有异步操作 this._subscribers = []; // ! resolver不为空函数 if (noop !== resolver) { // ! resolver必须为函数Function，否则报错 typeof resolver !== 'function' && needsResolver(); // ! 判断this是否来源于Promise构造函数（new Promise），是则调initializePromise函数，否则报错 this instanceof Promise ? initializePromise(this, resolver) : needsNew(); } } // 报错函数 function needsResolver() { throw new TypeError('You must pass a resolver function as the first argument to the promise constructor'); } // 报错函数 function needsNew() { throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\"); } // ! 执行new Promise传入的参数 resolve 或 reject 方法 // ! 入参是当前promise实例和传入的参数（函数方法或值） function initializePromise(promise, resolver) { // ? 将resolvePromise函数，rejectPromise函数当初参数传入 // ?，将执行结果当参数传入 try { resolver(function resolvePromise(value) { // ? resolve 执行方法 resolve$1(promise, value); }, function rejectPromise(reason) { // ? reject 执行方法 reject(promise, reason); }); } catch (e) { // ? 异常处理 reject(promise, e); } } // ! 执行完成处理方法 function resolve$1(promise, value) { // ? 当前返回值为promise实例，报错 if (promise === value) { reject(promise, selfFulfillment()); } else if (objectOrFunction(value)) { // ? 入参为对象或函数 var then$$1 = void 0; try { // ? 入参还存在then方法 then$$1 = value.then; } catch (error) { // ? 执行错误。抛出异常 reject(promise, error); return; } // ? 对参数进行进一步处理 handleMaybeThenable(promise, value, then$$1); } else { // ? 改变promise状态 fulfill(promise, value); } } // ! 入参做进一步处理 // ! 入参为当前promise实例，执行promise传入的参数，当前参数then方法 function handleMaybeThenable(promise, maybeThenable, then$$1) { // ? 判断当前入参是否与promise实例对象一致，且存在then方法，且存在resolve方法。 // ? 则根据当前promise状态，执行对应promise方法 if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$$1) { handleOwnThenable(promise, maybeThenable); } else { // ? 不存在then方法，执行结束方法 if (then$$1 === undefined) { fulfill(promise, maybeThenable); } else if (isFunction(then$$1)) { // ? 存在他很函数，执行trycatch方法 handleForeignThenable(promise, maybeThenable, then$$1); } else { // ? 其他情况 fulfill(promise, maybeThenable); } } } // ! 根据当前promise状态执行操作 function handleOwnThenable(promise, thenable) { if (thenable._state === FULFILLED) { fulfill(promise, thenable._result); } else if (thenable._state === REJECTED) { reject(promise, thenable._result); } else { subscribe(thenable, undefined, function (value) { return resolve$1(promise, value); }, function (reason) { return reject(promise, reason); }); } } // ! 修改promise状态为FULFILLED function fulfill(promise, value) { if (promise._state !== PENDING) { return; } promise._result = value; promise._state = FULFILLED; if (promise._subscribers.length !== 0) { asap(publish, promise); } } // ! 修改promise状态为REJECTED function reject(promise, reason) { if (promise._state !== PENDING) { return; } promise._state = REJECTED; promise._result = reason; asap(publishRejection, promise); } 普通promise流程图 总结： 1.初始化了_subscribers属性，说明Promise使用发布/订阅模式，间接证明promise**有异步操作；** 2.创建对象的时候执行initializePromise方法，说明构造函数接收的参数（类型为Function）是同步执行的 3.Promise三种状态 Pending， Fulfilled，Rejected，且状态只会改变一次，且不是可逆的 Promsion then操作方法 // ! Promise then方法 // ! Promise then方法返回的是一个新的promise对象 function then(onFulfillment, onRejection) { // ? this赋值给parent var parent = this; // ? 创建新的对象 var child = new this.constructor(noop); // ? 当前promise id为空则创建一个promise id if (child[PROMISE_ID] === undefined) { makePromise(child); } // ? 当前promise状态 var _state = parent._state; // ? 如果当前有状态值，则去当前状态的方法，根据状态执行不同promise方法 if (_state) { var callback = arguments[_state - 1]; asap(function () { return invokeCallback(_state, child, callback, parent._result); }); } else { // ? 执行队列任务 subscribe(parent, child, onFulfillment, onRejection); } // ? 返回创建的对象 return child; } Promsion catch操作方法 // ! 执行then方法，传入onRejection方法 Promise.prototype.catch = function _catch(onRejection) { return this.then(null, onRejection); }; Promsion finally操作方法 // ! finally方法当前promise实例 Promise.prototype.finally = function _finally(callback) { var promise = this; var constructor = promise.constructor; // ? 如果传入的值是函数，根据是执行完成或错误调用方法 if (isFunction(callback)) { return promise.then(function (value) { return constructor.resolve(callback()).then(function () { return value; }); }, function (reason) { return constructor.resolve(callback()).then(function () { throw reason; }); }); } // ? 入参不是函数，根据参数返回执行resolve或reject return promise.then(callback, callback); }; 总结：catch，finally根据入参调用promise.then的方法 Promsion all操作方法 入参promise实例的数组 function all(entries) { return new Enumerator(this, entries).promise; } var Enumerator = function () { // ! promise.all 执行方法 // ! promise.all 入参当前promise实例（this），promise集合（array） function Enumerator(Constructor, input) { // ? 赋值this实例 this._instanceConstructor = Constructor; // ? 重新创建新的实例对象 this.promise = new Constructor(noop); // ? 如果没有promise id则创建id if (!this.promise[PROMISE_ID]) { makePromise(this.promise); } // ? 入参是数组则执行流程，否则错误reject处理 if (isArray(input)) { // ? 记录promise数组长度 this.length = input.length; // ? 记录还有多少promise未执行，默认都没有执行 this._remaining = input.length; // ? 记录每个promise对象最终的返回值 this._result = new Array(this.length); if (this.length === 0) { // ? 空数组，改变promise状态为fulfilled，结束 fulfill(this.promise, this._result); } else { this.length = this.length || 0; // ? 顺序执行promise this._enumerate(input); if (this._remaining === 0) { //? 每个promise状态都变为fulfilled，结束 fulfill(this.promise, this._result); } } } else { reject(this.promise, validationError()); } } // ! 循环迭代每个promise对象，通过_eachEntry执行每个promise Enumerator.prototype._enumerate = function _enumerate(input) { for (var i = 0; this._state === PENDING && i 总结： 1.all方法的参数是一个promise的数组 2.promise.all()返回的是一个promise对象（父promise）。故可以链式的调用then方法 3.then(value)参数返回的是一组有序的值，内部会顺序的记录每一个promise对象的状态和值 4.所有promise对象改变后，触发**父promise状态更新** Promsion race操作方法 function race(entries) { /*jshint validthis:true */ var Constructor = this; // ? 入参不是数组则直接报错结束 if (!isArray(entries)) { return new Constructor(function (_, reject) { return reject(new TypeError('You must pass an array to race.')); }); } else { // ? 循环执行promise。每执行一个promise就改变父promise（race返回的promise对象） return new Constructor(function (resolve, reject) { var length = entries.length; for (var i = 0; i 总结： 1. promise.race入参是一个数组，如果不是数组则状态变为rejected，报错直接返回 2.循环遍历执行传入的promise，每执行就改变父promise（**promise.race返回的promise对象**） Promsion resolve操作方法 function resolve$$1(object) { /*jshint validthis:true */ var Constructor = this; // ? 如果入参是object且属性与promise的属性一致，直接返回入参 if (object && typeof object === 'object' && object.constructor === Constructor) { return object; } // ? 创建新的实例对象，执行resolve$1，更新promise状态，返回内部promise对象 var promise = new Constructor(noop); resolve$1(promise, object); return promise; } Promsion reject操作方法 // ! 创建对象，内部调用reject方法，改变状态为rejected状态。返回内部创建的promise对象 function reject$1(reason) { /*jshint validthis:true */ var Constructor = this; var promise = new Constructor(noop); reject(promise, reason); return promise; } Promsion asap操作方法 var asap = function asap(callback, arg) { queue[len] = callback; queue[len + 1] = arg; len += 2; if (len === 2) { //如果len为2，则意味着我们需要安排异步刷新。 //如果在刷新队列之前将其他回调排队在队列中，则它们 //将由我们计划的刷新处理 // If len is 2, that means that we need to schedule an async flush. // If additional callbacks are queued before the queue is flushed, they // will be processed by this flush that we are scheduling. if (customSchedulerFn) { customSchedulerFn(flush); } else { scheduleFlush(); } } }; 总结： 函数接收两个参数 callback 回调函数 arg 参数 参数存入队列 判断 len 长度 这里判断**len===2**的原因在于初始化**queue**数组长度为 1000 但值为**undefined**,将参数存入数组并判断长度只为确定数组内有值(可立即执行的函数). customSchedulerFn 对开发者提供了**setScheduler**方法对**customSchedulerFn**赋值实现定制化调用队列,(假如在此次准备开始调用队列之前还有其它事情要处理完成之后才可以调用,则可以实现 **customSchedulerFn** 函数)这里不做过多说明. scheduleFlush 这个函数针对不同的执行环境(Node、浏览器)等做了处理,由于我们在浏览器端执行,所以直接看**useMutationObserver**函数. powered by Gitbook该文件最后修改时间： 2021-10-17 10:40:27 "},"js知识点/常用js.html":{"url":"js知识点/常用js.html","title":"常用js","keywords":"","body":"常用js 延迟函数delay const delay = ms => new Promise((resolve, reject) => setTimeout(resolve, ms)) const getData = status => new Promise((resolve, reject) => { status ? resolve('done') : reject('fail') }) const getRes = async (data) => { try { const res = await getData(data) const timestamp = new Date().getTime() await delay(1000) console.log(res, new Date().getTime() - timestamp) } catch (error) { console.log(error) } } getRes(true) // 隔了1秒 分割指定长度的元素数组 const listChunk = (list, size = 1, cacheList = []) => { const tmp = [...list] if (size 获取数组交集 const intersection = (list, ...args) => list.filter(item => args.every(list => list.includes(item))) console.log(intersection([2, 1], [2, 3])) // [2] console.log(intersection([1, 2], [3, 4])) // [] 函数柯里化 const curring = fn => { const { length } = fn const curried = (...args) => { return (args.length >= length ? fn(...args) : (...args2) => curried(...args.concat(args2))) } return curried } const listMerge = (a, b, c) => [a, b, c] const curried = curring(listMerge) console.log(curried(1)(2)(3)) // [1, 2, 3] console.log(curried(1, 2)(3)) // [1, 2, 3] console.log(curried(1, 2, 3)) // [1, 2, 3] 字符串前面空格去除与替换 const trimStart = str => str.replace(new RegExp('^([\\s])(.)$'), '$2') console.log(trimStart(' abc ')) // abc console.log(trimStart('123 ')) // 123 字符串后面空格去除与替换 const trimEnd = str => str.replace(new RegExp('^(.?)([\\s])$'), '$1') console.log(trimEnd(' abc ')) // abc console.log(trimEnd('123 ')) // 123 获取当前子元素是其父元素下子元素的排位 const getIndex = el => { if (!el) { return -1 } let index = 0 do { index++ } while (el = el.previousElementSibling); return index } 获取当前元素相对于document的偏移量 const getOffset = el => { const { top, left } = el.getBoundingClientRect() const { scrollTop, scrollLeft } = document.body return { top: top + scrollTop, left: left + scrollLeft } } 获取元素类型 const dataType = obj => Object.prototype.toString.call(obj).replace(/^[object (.+)]$/, '$1').toLowerCase(); 判断是否是移动端 const isMobile = () => 'ontouchstart' in window fade动画 const fade = (el, type = 'in') { el.style.opacity = (type === 'in' ? 0 : 1) let last = +new Date() const tick = () => { const opacityValue = (type === 'in' ? (new Date() - last) / 400 : -(new Date() - last) / 400) el.style.opacity = +el.style.opacity + opacityValue last = +new Date() if (type === 'in' ? (+el.style.opacity 0)) { requestAnimationFrame(tick) } } tick() } 将指定格式的字符串解析为日期字符串 const dataPattern = (str, format = '-') => { if (!str) { return new Date() } const dateReg = new RegExp(^(\\\\d{2})${format}(\\\\d{2})${format}(\\\\d{4})$) const [, month, day, year] = dateReg.exec(str) return new Date(${month}, ${day} ${year}) } console.log(dataPattern('12-25-1995')) // Mon Dec 25 1995 00:00:00 GMT+0800 (中国标准时间) 禁止网页复制粘贴 const html = document.querySelector('html') html.oncopy = () => false html.onpaste = () => false input框限制只能输入中文 const input = document.querySelector('input[type=\"text\"]') const clearText = target => { const { value } = target target.value = value.replace(/[^\\u4e00-\\u9fa5]/g, '') } input.onfocus = ({target}) => { clearText(target) } input.onkeyup = ({target}) => { clearText(target) } input.onblur = ({target}) => { clearText(target) } input.oninput = ({target}) => { clearText(target) } 去除字符串中的html代码 const removehtml = (str = '') => str.replace(/]>/ig, '') console.log(removehtml('哈哈哈哈')) // 哈哈哈哈 powered by Gitbook该文件最后修改时间： 2021-10-17 10:39:14 "},"vue2源码解析/起步.html":{"url":"vue2源码解析/起步.html","title":"vue2源码解析","keywords":"","body":"起步 powered by Gitbook该文件最后修改时间： 2021-10-16 18:48:44 "},"vue3源码解析/起步.html":{"url":"vue3源码解析/起步.html","title":"vue3源码解析","keywords":"","body":" 起步 powered by Gitbook该文件最后修改时间： 2021-10-16 14:49:39 "},"浏览器/cookie， session，单点登录，token.html":{"url":"浏览器/cookie， session，单点登录，token.html","title":"浏览器","keywords":"","body":"cookie，session，单点登录，token 1 cookie 在提供标记的接口，通过HTTP返回头的Set-Cookie字段，直接种在浏览器上 浏览器发送请求的时候会直接带给接口 通过配置Domain/Path，可以设置在相同域名或者Path地址上携带该cookie cookie有效期设置 Expires： 设置具体的时间，指浏览器到达指定时间就失效 Max-Age： 设置的是秒数，过了这个时间，浏览器就不保存cookie了 Max-Age优先级高于Expires，如果设置Max-Age和Expires，那么Max-Age会优先生效 Secure/HttpOnly Secure是指浏览器只有在Https下，才会把cookie发送到服务器 HttpOnly是指禁止通过js脚本获取cookie，只能在请求头中进行cookie的传输 2 session 浏览器登录账户密码 服务端通过查询用户库校验账号密码有效性 校验成功，服务器把用户登录状态存为session，生成一个sessionId 通过登录接口返回，把sessionId set到cookie上 浏览器请求接口的时候会把sessionId随cookie带上 服务端查询session表，校验session 成功后会返回结果 session 存储方式 redis：内存型数据库，以key-value的方式存，访问快 内存：直接存在变量中，重启服务就没有了 数据库：普通数据库，性能不高 3 Token token流程： 用户登录账号密码，服务端查询用户表，校验账号密码 返回用户数据生成token，通过set cookie设置到浏览器中 用户请求接口会通过cookie携带token 服务端校验token的有效性，进行正常的业务接口处理 token可以通过cookie保存也可以自定义参数保存，是无状态的 token通过base64，jwt都可以生成 refresh token 目的： 避免token频繁过期，用户退出登录，通过refresh token获取access token，有效期可以长一点，通过独立的服务和严格的请求方式增加安全性 refresh token流程 用户登录账号密码，服务端查询用户表，校验账号密码，在认证服务生成refresh token和access token 返回refresh token和access token到客户端存储起来 用户进行业务处理，如果access token有效则进行接口数据处理 如果access token无效，则校验refresh token是否有效，在认证服务依据refresh token生成最新的access token，进行接口操作树立 如果refresh token无效，则只能退出登录 4. 单点登录 4.1 主域名相同的单点登录 系统在同一个主域名下，利于a.baidu.com b.baidu.com则直接把cookie domain设置为主域名 baidu.com 4.2 主域名不同的单点登录 例如：a.cc.com, b.dd.com, c.ee.com实现一次登录，全线通用，则需要sso（独立的认证服务） 在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定 浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket 这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效 callback 接口拿到 ticket 后，在自己的域下 set cookie 成功 在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好 访问 B 系统也是一样 powered by Gitbook该文件最后修改时间： 2021-10-17 12:05:53 "},"工程化/eslite配置表.html":{"url":"工程化/eslite配置表.html","title":"工程化","keywords":"","body":"eslite配置表 { // 环境定义了预定义的全局变量。 \"env\": { //环境定义了预定义的全局变量。更多在官网查看 \"browser\": true, \"node\": true, \"commonjs\": true, \"amd\": true, \"es6\": true, \"mocha\": true }, // JavaScript 语言选项 \"parserOptions\": { // ECMAScript 版本 \"ecmaVersion\": 6, \"sourceType\": \"module\", //设置为 \"script\" (默认) 或 \"module\"（如果你的代码是 ECMAScript 模块)。 //想使用的额外的语言特性: \"ecmaFeatures\": { // 允许在全局作用域下使用 return 语句 \"globalReturn\": true, // impliedStric \"impliedStrict\": true, // 启用 JSX \"jsx\": true, \"modules\": true } }, //-----让eslint支持 JSX start \"plugins\": [ \"react\" ], \"extends\": [ \"eslint:recommended\", \"plugin:react/recommended\" ], //-----让eslint支持 JSX end /** * \"off\" 或 0 - 关闭规则 * \"warn\" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出), * \"error\" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) */ \"rules\": { //////////////// // 可能的错误 // //////////////// // 禁止条件表达式中出现赋值操作符 \"no-cond-assign\": 2, // 禁用 console \"no-console\": 0, // 禁止在条件中使用常量表达式 // if (false) { // doSomethingUnfinished(); // } //cuowu \"no-constant-condition\": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\") \"no-control-regex\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [1, \"never\"], // 禁用 debugger \"no-debugger\": 2, // 禁止 function 定义中出现重名参数 \"no-dupe-args\": 2, // 禁止对象字面量中出现重复的 key \"no-dupe-keys\": 2, // 禁止重复的 case 标签 \"no-duplicate-case\": 2, // 禁止空语句块 \"no-empty\": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) \"no-empty-character-class\": 2, // 禁止对 catch 子句的参数重新赋值 \"no-ex-assign\": 2, // 禁止不必要的布尔转换 \"no-extra-boolean-cast\": 2, // 禁止不必要的括号 //(a * b) + c;//报错 \"no-extra-parens\": 0, // 禁止不必要的分号 \"no-extra-semi\": 2, // 禁止对 function 声明重新赋值 \"no-func-assign\": 2, // 禁止在嵌套的块中出现 function 或 var 声明 \"no-inner-declarations\": [2, \"functions\"], // 禁止 RegExp 构造函数中无效的正则表达式字符串 \"no-invalid-regexp\": 2, // 禁止在字符串和注释之外不规则的空白 \"no-irregular-whitespace\": 2, // 禁止在 in 表达式中出现否定的左操作数 \"no-negated-in-lhs\": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); \"no-obj-calls\": 2, // 禁止直接使用 Object.prototypes 的内置属性 \"no-prototype-builtins\": 0, // 禁止正则表达式字面量中出现多个空格 \"no-regex-spaces\": 2, // 禁用稀疏数组 \"no-sparse-arrays\": 2, // 禁止出现令人困惑的多行表达式 \"no-unexpected-multiline\": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 \"no-unreachable\": 2, // 要求使用 isNaN() 检查 NaN \"use-isnan\": 2, // 强制使用有效的 JSDoc 注释 \"valid-jsdoc\": 1, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === \"undefimed\" 错误 \"valid-typeof\": 2, ////////////// // 最佳实践 // ////////////// // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 强制数组方法的回调函数中有 return 语句 \"array-callback-return\": 0, // 强制把变量的使用限制在其定义的作用域范围内 \"block-scoped-var\": 0, // 限制圈复杂度，也就是类似if else能连续接多少个 \"complexity\": [2, 9], // 要求 return 语句要么总是指定返回的值，要么不指定 \"consistent-return\": 0, // 强制所有控制语句使用一致的括号风格 \"curly\": [2, \"all\"], // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, {\"allowKeywords\": false}] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, {\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"}] \"dot-notation\": [2, { \"allowKeywords\": false }], // 使用 === 替代 == allow-null允许null和undefined== \"eqeqeq\": [2, \"allow-null\"], // 要求 for-in 循环中有一个 if 语句 \"guard-for-in\": 2, // 禁用 alert、confirm 和 prompt \"no-alert\": 0, // 禁用 arguments.caller 或 arguments.callee \"no-caller\": 2, // 不允许在 case 子句中使用词法声明 \"no-case-declarations\": 2, // 禁止除法操作符显式的出现在正则表达式开始的位置 \"no-div-regex\": 2, // 禁止 if 语句中有 return 之后有 else \"no-else-return\": 0, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 \"no-empty-function\": 2, // 禁止使用空解构模式no-empty-pattern \"no-empty-pattern\": 2, // 禁止在没有类型检查操作符的情况下与 null 进行比较 \"no-eq-null\": 1, // 禁用 eval() \"no-eval\": 2, // 禁止扩展原生类型 \"no-extend-native\": 2, // 禁止不必要的 .bind() 调用 \"no-extra-bind\": 2, // 禁用不必要的标签 \"no-extra-label:\": 0, // 禁止 case 语句落空 \"no-fallthrough\": 2, // 禁止数字字面量中使用前导和末尾小数点 \"no-floating-decimal\": 2, // 禁止使用短符号进行类型转换(!!fOO) \"no-implicit-coercion\": 0, // 禁止在全局范围内使用 var 和命名的 function 声明 \"no-implicit-globals\": 1, // 禁止使用类似 eval() 的方法 \"no-implied-eval\": 2, // 禁止 this 关键字出现在类和类对象之外 \"no-invalid-this\": 0, // 禁用 __iterator__ 属性 \"no-iterator\": 2, // 禁用标签语句 \"no-labels\": 2, // 禁用不必要的嵌套块 \"no-lone-blocks\": 2, // 禁止在循环中出现 function 声明和表达式 \"no-loop-func\": 1, // 禁用魔术数字(3.14什么的用常量代替) \"no-magic-numbers\": [1, { \"ignore\": [0, -1, 1] }], // 禁止使用多个空格 \"no-multi-spaces\": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 \"no-multi-str\": 2, // 禁止对原生对象赋值 \"no-native-reassign\": 2, // 禁止在非赋值或条件语句中使用 new 操作符 \"no-new\": 2, // 禁止对 Function 对象使用 new 操作符 \"no-new-func\": 0, // 禁止对 String，Number 和 Boolean 使用 new 操作符 \"no-new-wrappers\": 2, // 禁用八进制字面量 \"no-octal\": 2, // 禁止在字符串中使用八进制转义序列 \"no-octal-escape\": 2, // 不允许对 function 的参数进行重新赋值 \"no-param-reassign\": 0, // 禁用 __proto__ 属性 \"no-proto\": 2, // 禁止使用 var 多次声明同一变量 \"no-redeclare\": 2, // 禁用指定的通过 require 加载的模块 \"no-return-assign\": 0, // 禁止使用 javascript: url \"no-script-url\": 0, // 禁止自我赋值 \"no-self-assign\": 2, // 禁止自身比较 \"no-self-compare\": 2, // 禁用逗号操作符 \"no-sequences\": 2, // 禁止抛出非异常字面量 \"no-throw-literal\": 2, // 禁用一成不变的循环条件 \"no-unmodified-loop-condition\": 2, // 禁止出现未使用过的表达式 \"no-unused-expressions\": 0, // 禁用未使用过的标签 \"no-unused-labels\": 2, // 禁止不必要的 .call() 和 .apply() \"no-useless-call\": 2, // 禁止不必要的字符串字面量或模板字面量的连接 \"no-useless-concat\": 2, // 禁用不必要的转义字符 \"no-useless-escape\": 0, // 禁用 void 操作符 \"no-void\": 0, // 禁止在注释中使用特定的警告术语 \"no-warning-comments\": 0, // 禁用 with 语句 \"no-with\": 2, // 强制在parseInt()使用基数参数 \"radix\": 2, // 要求所有的 var 声明出现在它们所在的作用域顶部 \"vars-on-top\": 0, // 要求 IIFE 使用括号括起来 \"wrap-iife\": [2, \"any\"], // 要求或禁止 “Yoda” 条件 \"yoda\": [2, \"never\"], // 要求或禁止使用严格模式指令 \"strict\": 0, ////////////// // 变量声明 // ////////////// // 要求或禁止 var 声明中的初始化(初值) \"init-declarations\": 0, // 不允许 catch 子句的参数与外层作用域中的变量同名 \"no-catch-shadow\": 0, // 禁止删除变量 \"no-delete-var\": 2, // 不允许标签与变量同名 \"no-label-var\": 2, // 禁用特定的全局变量 \"no-restricted-globals\": 0, // 禁止 var 声明 与外层作用域的变量同名 \"no-shadow\": 0, // 禁止覆盖受限制的标识符 \"no-shadow-restricted-names\": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 \"no-undef\": 2, // 禁止将变量初始化为 undefined \"no-undef-init\": 2, // 禁止将 undefined 作为标识符 \"no-undefined\": 0, // 禁止出现未使用过的变量 \"no-unused-vars\": [2, { \"vars\": \"all\", \"args\": \"none\" }], // 不允许在变量定义之前使用它们 \"no-use-before-define\": 0, ////////////////////////// // Node.js and CommonJS // ////////////////////////// // require return statements after callbacks \"callback-return\": 0, // 要求 require() 出现在顶层模块作用域中 \"global-require\": 1, // 要求回调函数中有容错处理 \"handle-callback-err\": [2, \"^(err|error)$\"], // 禁止混合常规 var 声明和 require 调用 \"no-mixed-requires\": 0, // 禁止调用 require 时使用 new 操作符 \"no-new-require\": 2, // 禁止对 __dirname 和 __filename进行字符串连接 \"no-path-concat\": 0, // 禁用 process.env \"no-process-env\": 0, // 禁用 process.exit() \"no-process-exit\": 0, // 禁用同步方法 \"no-sync\": 0, ////////////// // 风格指南 // ////////////// // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 禁止或强制在单行代码块中使用空格(禁用) \"block-spacing\": [1, \"never\"], //强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用tab， // if while function 后面的{必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", { \"allowSingleLine\": true }], // 双峰驼命名格式 \"camelcase\": 2, // 控制逗号前后的空格 \"comma-spacing\": [2, { \"before\": false, \"after\": true }], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], //\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2, \"never\"], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": [1, \"that\"], // 强制使用命名的 function 表达式 \"func-names\": 0, // 文件末尾强制换行 \"eol-last\": 2, \"indent\": [2, 4, { \"SwitchCase\": 1 }], // 强制在对象字面量的属性中键和值之间使用一致的间距 \"key-spacing\": [2, { \"beforeColon\": false, \"afterColon\": true }], // 强制使用一致的换行风格 \"linebreak-style\": [1, \"unix\"], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) \"lines-around-comment\": [1, { \"beforeBlockComment\": true }], // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f(){} e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() {} e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", { \"allowArrowFunctions\": true }] \"func-style\": 0, // 强制回调函数最大嵌套深度 5层 \"max-nested-callbacks\": [1, 5], // 禁止使用指定的标识符 \"id-blacklist\": 0, // 强制标识符的最新和最大长度 \"id-length\": 0, // 要求标识符匹配一个指定的正则表达式 \"id-match\": 0, // 强制在 JSX 属性中一致地使用双引号或单引号 \"jsx-quotes\": 0, // 强制在关键字前后使用一致的空格 (前后腰需要) \"keyword-spacing\": 2, // 强制一行的最大长度 \"max-len\": [1, 200], // 强制最大行数 \"max-lines\": 0, // 强制 function 定义中最多允许的参数数量 \"max-params\": [1, 7], // 强制 function 块最多允许的的语句数量 \"max-statements\": [1, 200], // 强制每一行中所允许的最大语句数量 \"max-statements-per-line\": 0, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） \"new-cap\": [2, { \"newIsCap\": true, \"capIsNew\": false }], // 要求调用无参构造函数时有圆括号 \"new-parens\": 2, // 要求或禁止 var 声明语句后有一行空行 \"newline-after-var\": 0, // 禁止使用 Array 构造函数 \"no-array-constructor\": 2, // 禁用按位运算符 \"no-bitwise\": 0, // 要求 return 语句之前有一空行 \"newline-before-return\": 0, // 要求方法链中每个调用都有一个换行符 \"newline-per-chained-call\": 1, // 禁用 continue 语句 \"no-continue\": 0, // 禁止在代码行后使用内联注释 \"no-inline-comments\": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 \"no-lonely-if\": 0, // 禁止混合使用不同的操作符 \"no-mixed-operators\": 0, // 不允许空格和 tab 混合缩进 \"no-mixed-spaces-and-tabs\": 2, // 不允许多个空行 \"no-multiple-empty-lines\": [2, { \"max\": 2 }], // 不允许否定的表达式 \"no-negated-condition\": 0, // 不允许使用嵌套的三元表达式 \"no-nested-ternary\": 0, // 禁止使用 Object 的构造函数 \"no-new-object\": 2, // 禁止使用一元操作符 ++ 和 -- \"no-plusplus\": 0, // 禁止使用特定的语法 \"no-restricted-syntax\": 0, // 禁止 function 标识符和括号之间出现空格 \"no-spaced-func\": 2, // 不允许使用三元操作符 \"no-ternary\": 0, // 禁用行尾空格 \"no-trailing-spaces\": 2, // 禁止标识符中有悬空下划线_bar \"no-underscore-dangle\": 0, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 \"no-unneeded-ternary\": 2, // 禁止属性前有空白 \"no-whitespace-before-property\": 0, // 强制花括号内换行符的一致性 \"object-curly-newline\": 0, // 强制在花括号中使用一致的空格 \"object-curly-spacing\": 0, // 强制将对象的属性放在不同的行上 \"object-property-newline\": 0, // 强制函数中的变量要么一起声明要么分开声明 \"one-var\": [2, { \"initialized\": \"never\" }], // 要求或禁止在 var 声明周围换行 \"one-var-declaration-per-line\": 0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 \"operator-assignment\": 0, // 强制操作符使用一致的换行符 \"operator-linebreak\": [2, \"after\", { \"overrides\": { \"?\": \"before\", \":\": \"before\" } }], // 要求或禁止块内填充 \"padded-blocks\": 0, // 要求对象字面量属性名称用引号括起来 \"quote-props\": 0, // 强制使用一致的反勾号、双引号或单引号 \"quotes\": [2, \"double\", \"avoid-escape\"], // 要求使用 JSDoc 注释 \"require-jsdoc\": 1, // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） \"semi\": [2, \"always\"], // 强制分号之前和之后使用一致的空格 \"semi-spacing\": 0, // 要求同一个声明块中的变量按顺序排列 \"sort-vars\": 0, // 强制在块之前使用一致的空格 \"space-before-blocks\": [2, \"always\"], // 强制在 function的左括号之前使用一致的空格 \"space-before-function-paren\": [0, \"always\"], // 强制在圆括号内使用一致的空格 \"space-in-parens\": [2, \"never\"], // 要求操作符周围有空格 \"space-infix-ops\": 2, // 强制在一元操作符前后使用一致的空格 \"space-unary-ops\": [2, { \"words\": true, \"nonwords\": false }], // 强制在注释中 // 或 /* 使用一致的空格 \"spaced-comment\": [2, \"always\", { \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"] }], // 要求或禁止 Unicode BOM \"unicode-bom\": 0, // 要求正则表达式被括号括起来 \"wrap-regex\": 0, ////////////// // ES6.相关 // ////////////// // 要求箭头函数体使用大括号 \"arrow-body-style\": 2, // 要求箭头函数的参数使用圆括号 \"arrow-parens\": 2, \"arrow-spacing\": [2, { \"before\": true, \"after\": true }], // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // 强制 generator 函数中 * 号周围使用一致的空格 \"generator-star-spacing\": [2, { \"before\": true, \"after\": true }], // 禁止修改类声明的变量 \"no-class-assign\": 2, // 不允许箭头功能，在那里他们可以混淆的比较 \"no-confusing-arrow\": 0, // 禁止修改 const 声明的变量 \"no-const-assign\": 2, // 禁止类成员中出现重复的名称 \"no-dupe-class-members\": 2, // 不允许复制模块的进口 \"no-duplicate-imports\": 0, // 禁止 Symbol 的构造函数 \"no-new-symbol\": 2, // 允许指定模块加载时的进口 \"no-restricted-imports\": 0, // 禁止在构造函数中，在调用 super() 之前使用 this 或 super \"no-this-before-super\": 2, // 禁止不必要的计算性能键对象的文字 \"no-useless-computed-key\": 0, // 要求使用 let 或 const 而不是 var \"no-var\": 0, // 要求或禁止对象字面量中方法和属性使用简写语法 \"object-shorthand\": 0, // 要求使用箭头函数作为回调 \"prefer-arrow-callback\": 0, // 要求使用 const 声明那些声明后不再被修改的变量 \"prefer-const\": 0, // 要求在合适的地方使用 Reflect 方法 \"prefer-reflect\": 0, // 要求使用扩展运算符而非 .apply() \"prefer-spread\": 0, // 要求使用模板字面量而非字符串连接 \"prefer-template\": 0, // Suggest using the rest parameters instead of arguments \"prefer-rest-params\": 0, // 要求generator 函数内有 yield \"require-yield\": 0, // enforce spacing between rest and spread operators and their expressions \"rest-spread-spacing\": 0, // 强制模块内的 import 排序 \"sort-imports\": 0, // 要求或禁止模板字符串中的嵌入表达式周围空格的使用 \"template-curly-spacing\": 1, // 强制在 yield* 表达式中 * 周围使用空格 \"yield-star-spacing\": 2 } } powered by Gitbook该文件最后修改时间： 2021-10-17 10:43:51 "},"工程化/cli开发.html":{"url":"工程化/cli开发.html","title":"cli开发","keywords":"","body":"cli开发 1. 基本知识 1.1 什么是npm npm由网站，命令行界面(cli)，注册表组成。 npm 是Node.js默认的，用JavaScript编写的软件包管理系统。npm会随着Node.js自动安装。 通过“registry”的查询服务，用户可以通过本地的npm命令下载安装指定的模块，用户也可以将自己设计的模块 分发到registry上面。 registry上面的模块通常采用CommonJS格式，而且都包含一个JSON格式的元文件。 npm的模块以“先到先得”的原则注册，各模块作者不会发生混乱。 缺点： 一旦有人撤回自己发布的模块，会使依赖那个模块的项目出现问题，还会带来安全风险。 registry没有审核机制，会存在一些低质量，不安全甚至有害的模块。 npm config ls -l // 查找npm包配置 1.2 npm安装使用 本地项目中安装 npm install （--save-dev或--save） devependencies 和 dependencies 只有在特定环境才会生效，例如在下载npm插件的时候，不需要引用插件的依赖包 // save-dev会被记录在package.json的devependencies下，当进行代码打包时，不会将这里的插件源码打包入我们的项目代码中 // save 它就会被记录在package.json的dependencies。当进行代码打包时，会将插件打包入我们的项目代码中 // webpack项目打包跟devependencies和dependencies无太大关系，webpack打包是依赖于node_modules文件夹的， // 只要这个文件夹里有相应的模块，就可以打包 全局安装 npm install -g 或者npm install -g // 全局安装默认在/usr/local // 如果是win32 则安装在/usr/local/node_modules,否则/usr/local/lib/node_modules // cli/lib/install.js // cli/lib/utils/flat-options.js this.globalPrefix = '/usr/local' // cli/lib/npm.js get globalDir () { return process.platform !== 'win32' ? resolve(this.globalPrefix, 'lib', 'node_modules') : resolve(this.globalPrefix, 'node_modules') } 插件安装后可以通过require(ES5)或者import 1.3 #!/usr/bin/env node 含义 #!usr/bin/env node主要是帮助脚本找到 node 的脚本解释器 #！含义在Linux或者Unix中叫做：shebang%5D(https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FShebang_(Unix))%2C)，unix类操作系统中一个普通文件带有#!开头的，就会当做一个执行文件来运行，#就是注释的含义 usr/bin/env node 是指通过node来执行文件，usr/bin/env 指在当前路径的env环境变量中去查找。 由于Windows不支持shebang行，因此npm创建了一个包装 *.cmd（批处理）文件，该文件使用脚本文件shebang行中指定的任何可执行文件显式调用“二进制”文件（在bin键中package.json指定的脚本文件） 1.4 npm link npm link 的作用相当于是将我们的工程进行了全局安装,通过npm prefix -g可以查看安装路径 卸载模块 npm uninstall -g 2. 什么是CLI cli是用户通过键盘输入指令，计算机接收到指令后，予以执行。相对于图形用户界面，操作速度更快，但是需要记更多的操作命令 3. 如何开发CLI 3.1 命令行参数处理 commander node 中有自带的process对象提供有关当前node.js 进程的信息和控制的全局对象,我们一般用第三方模块进行处理 commander 源码地址：https://github.com/tj/commander.js commander特征： 自动记录代码，自动生成帮助，合并短参数，默认选项，强制选项，命令解析，提示符 version 方法：定义命令程序版本 const program = require('commander') // 定义命令程序版本 program .version('0.0.1') // 自定义flag,--version不能省略 program .version('0.0.1', '-m, --version') program.parse(process.argv) option方法：定义命令选项 自定义的flag，一长一短的flag，可以用逗号，竖线或空格隔开，flag后面可以跟参数 <>代表必填，[]定义可选参数 选项描述（可省略），通过-h或--help可查看 选项默认值（可省略） program // .option('-a --add', 'add something') .option('--more-word', 'moreWord') // 多单词形式 .option('-a --add [file]', 'not word', 'ss') // 选项默认值 command方法：自定义命令 写法： 自定义命令名称，名称必填，命令参数通过<>或[]定义 命令描述（可省略） 配置选项 program .command('my [otherDirs...]') .description('message') .action((name, otherDirs, cmd) => { console.log('name', name) console.log('otherDirs', otherDirs) // console.log('cmd', cmd) }) description 方法： 命令的描述性语句 action() 方法：定义命令的回调函数 parse方法：解析process.argv，设置options以及触发commands 参数： process.argv 属性会返回一个数组，其中包含当 Node.js 进程被启动时传入的命令行参数 // 打印 process.argv。 process.argv.forEach((val, index) => { console.log(`${index}: ${val}`); }); 3.2 交互式命令 inquirer 参数 含义 type 提示问题的类型：input，confirm,list,rawlist,expand,checkbox,editor name 当前问题回答的变量 message 问题的描述 default 默认值 choices 列表选项，包含一个分隔符（separator） validate 对用户的回答进行有效验证 filter 对用户回答进行过滤处理，返回处理的值 transformer 对用户回答的显示效果处理 when 根据前面问题回答，判断当前问题是否需要回答 prefix 修改message默认前缀 suffix 修改message默认后缀 3.3 文件下载 download-git-repo 参数： 第一个参数是下载路径，第二个参数下载文件存放位置，第三个是回调函数，可以对错误进行处理 3.4 cli 发布 官网注册账号 https://www.npmjs.com/ 通过命令行登陆npm（npm login） 当前待发布包下输入npm publish 发布成功 3.5 更新版本 修改package.json 中version字段 npm version patch-->1.0.1：属于小修改，不更改功能使用 npm version minor-->1.1.0:可能添加了一些功能，不影响以前的使用。 npm version major-->2.0.0:可能改了API，输入大范围的修改 3.6 包的使用 通过npm安装 3.7 发布后取消或删除npm 包 npm unpublish --force // 强制取消 npx force-unpublish package-name '原因描述' // 删除 4 实战 https://github.com/reallyloveme/vue-cli-auto https://github.com/reallyloveme/sj-vite 4.1 hellow world // 创建文件夹 mkdir // npm 初始化 npm init -y // 创建index.js文件 #!/usr/bin/env node process.argv.forEach((val, index) => { if (val === 'hello') { console.log('hello world!') } }) // package.json里面创建 \"bin\":{ \"cli\": \"./index.js\" } // 执行npm link // 输入cli hello，就可以看到 hello world！ 4.2 下载初始化模版项目 创建cli项目文件 npm初始化 npm init -y 创建文件目录和文件 bin/index.js 修改package.json配置 执行npm link 输入 cli命令 // 安装插件 npm i commander --save-dev npm i download-git-repo --save-dev npm i ora --save-dev npm i clear --save-dev // bin/index.js #!/usr/bin/env node const program = require('commander') // commander库 const ora = require('ora') const { promisify } = require('util') const clear = require('clear') // 清除 program.version(require('./package.json').version) program .command('init ') .description('init project ') .action((name) => { console.log(name) const spinner = ora(`下载…… ${name}`) clear() const download = promisify(require('download-git-repo')) spinner.start() download('github:reallyloveme/vue-template', name) spinner.succeed() }) program.parse(process.argv) // package.json \"bin\": { \"cli\": \"./index.js\" } powered by Gitbook该文件最后修改时间： 2021-10-17 11:02:24 "},"webpack知识/webpack基本用法.html":{"url":"webpack知识/webpack基本用法.html","title":"webpack知识","keywords":"","body":"webpack 一：初始化项目，安装webpack npm init -y npm install webpack webpack-cli --save-dev 二：hello webapck 安装lodash npm install --save lodash // index.js import _ from 'lodash' function component() { var element = document.createElement('div') // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 // Lodash, now imported by this script element.innerHTML = _.join(['Hello', 'webpack'], ' ') return element } document.body.appendChild(component()) // package.json { \"name\": \"webpack-demon\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"css-loader\": \"^3.5.3\", \"style-loader\": \"^1.2.1\", \"webpack\": \"^4.43.0\", \"webpack-cli\": \"^3.3.11\" }, \"dependencies\": { \"lodash\": \"^4.17.15\" } } // webpack.config.js const path = require('path') module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } // index.html asset management 三：加载css ......安装插件 npm install --save-dev style-loader css-loader ......新增style.css文件 // style.css .hello { color: red; } //index.js import _ from 'lodash' import './style.css' function component() { var element = document.createElement('div') // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 // Lodash, now imported by this script element.innerHTML = _.join(['Hello', 'webpack'], ' ') element.classList.add('hello') return element } document.body.appendChild(component()) // webpack.config.js const path = require('path') module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ] } } 打包后文件 四：加载图片 ......安装插件 npm install --save-dev file-loader // webpack.config.js const path = require('path') module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] }, { test: /\\.(png|svg|jpg|gif)$/, use: ['file-loader'] } ] } } // index.js import _ from 'lodash' import './style.css' import icon from './icon.jpg' function component() { var element = document.createElement('div') // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 // Lodash, now imported by this script element.innerHTML = _.join(['Hello', 'webpack'], ' ') element.classList.add('hello') // 图像嵌入div const myIcon = new Image() myIcon.src = icon element.appendChild(myIcon) return element } document.body.appendChild(component()) 五：加载数据 ......安装插件 npm install --save-dev csv-loader xml-loader 六：管理输出 // 设置HtmlWebpackPlugin ......安装HtmlWebpackPlugin npm install --save-dev html-webpack-plugin // 清理dist文件 ......安装插件clean-webpack-plugin npm install clean-webpack-plugin --save-dev powered by Gitbook该文件最后修改时间： 2021-10-17 10:57:40 "},"mysql/基本用法.html":{"url":"mysql/基本用法.html","title":"mysql","keywords":"","body":"基本用法 创建数据库 CREATE DATABASE test; 删除数据库 DROP DATABASE test; 选择数据库 USE USE test; 创建数据库表 CREATE CREATE TABLE IF NOT EXISTS TEST_TABLE (id INT UNSIGNED AUTO_INCREMENT,test_title VARCHAR(100) NOT NULL,test_author VARCHAR(40) NOT NULL,submission_date DATE,PRIMARY KEY ( id ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; 查询数据表 SELECT * FROM TEST_TABLE; 删除数据库表 DROP TABLE DROP TABLE TEST_TABLE; 插入数据 INSERT INTO TEST_TABLE (test_title,test_author,submission_date) VALUES (\"测试数据一\",\"宋君\",NOW()); 批量插入数据 INSERT INTO INSERT INTO TEST_TABLE ( test_title, test_author, submission_date ) VALUES ( \"测试数据二\", \"宋君二\", NOW() ), ( \"测试数据三\", \"宋君三\", NOW() ), ( \"测试数据四\", \"宋君四\", NOW() ); 查询数据库表 SELECT……FROM…… SELECT * FROM TEST_TABLE WHERE id=1; 更新数据库 UPDATE UPDATE TEST_TABLE SET test_title='测试数据更新' WHERE id=2; 删除数据表数据 DELETE DELETE FROM TEST_TABLE WHERE id=4; LIKE 子句 %字符来表示任意字符 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 SELECT * FROM TEST_TABLE WHERE test_author LIKE '%二'; UNION 操作符 UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据 -- expression1, expression2, ... expression_n: 要检索的列。 -- tables: 要检索的数据表。 -- WHERE conditions: 可选， 检索条件。 -- DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 -- ALL: 可选，返回所有结果集，包含重复数据。 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; 排序数据库表 ORDER BY SELECT * FROM TEST_TABLE ORDER BY id DESC; 删除， 添加，修改表字段 ALTER TABLE ALTER TABLE TEST_TABL DROP count; ALTER TABLE TEST_TABLE ADD count INT; ALTER TABLE TEST_TABLE CHANGE count count2 CHAR(2); powered by Gitbook该文件最后修改时间： 2021-10-17 10:46:49 "}}